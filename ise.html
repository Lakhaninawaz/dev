<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../hover.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://getbootstrap.com/docs/5.3/assets/css/docs.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6576979529353132"
    crossorigin="anonymous"></script> -->
  <title>Computer Material | Sem 4 | ISE</title>
</head>
<body>

  <div include-html="navbar.html"></div>

  <button id="myBtn"><a href="#top" style="color: white">&ShortUpArrow;</a></button>

  <section class="box-content box-1 box-style-1" id="box-featured">
    <div class="container-fluid">


      <div class="title-degree">
        <h2 class="course_name_long_text">COMPUTER</h2>-
      </div>

      <div class="title-branch">
        <h4>SEM - 4</h4>
        <h2> Your All Units</h2>
      </div>


    </div>


    <div class="btnGroup filter-btn">
      <a class="btn btn-outline-danger" onclick="filterSelection('unit-1')" href="#unit-1" role="button">Unit-1</a>
      <a class="btn btn-outline-danger" onclick="filterSelection('unit-2')" href="#unit-2" role="button">Unit-2</a>
      <a class="btn btn-outline-danger" onclick="filterSelection('unit-3')" href="#unit-3" role="button">Unit-3</a>
      <a class="btn btn-outline-danger" onclick="filterSelection('unit-4')" href="#unit-4" role="button">Unit-4</a>
      <a class="btn btn-outline-danger" onclick="filterSelection('PDFs-ise')" href="#" role="button">PDFs</a>
    </div>

    <div class="container mt-5">

      <!-- <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 g-3"> -->

      <div class="col">
        <div class="card shadow-sm">
          <div class="card-body">
            <h4 class="bg-body-tertiary py-3">SUBJECT: Introduction to Software Engineering</h4>
          </div>
          <div class="unit border py-3 mx-3 filterDiv unit-1" id="unit-1">
            <h4 class="fw-bold">Unit –1: Software Process Models
            </h4><br>
            <div class="u-point">
              <p class="point">1.1 Defining software</p>
              <div class="u-point-expand">
                <p>Software is a set of instructions, data or programs used to operate computers and execute specific
                  tasks. It is the opposite of hardware, which describes the physical aspects of a computer. Software is
                  a generic term used to refer to applications, scripts and programs that run on a device. It can be
                  thought of as the variable part of a computer, while hardware is the invariable part. <br><br>

                  Software engineering is the application of a systematic, disciplined, and quantifiable approach to the
                  design, development, operation, and maintenance of software products. It involves the use of
                  well-defined scientific principles, techniques, and procedures to deliver software that meets the
                  requirements of customers and users. Software engineering also covers the aspects of software project
                  management, software quality assurance, software testing, software maintenance, and software
                  evolution.<br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/software-engineering-introduction-to-software-engineering/amp/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">1.2 Software Application Domain
                i. System Software
                ii. Application Software
                iii. Embedded Software
                iv. Web Application
                v. Artificial Intelligence Software</p>
              <div class="u-point-expand">
                <p>A software application domain is the segment of reality for which a software system is developed. It
                  is the background or starting point for the analysis and design of a software product that meets the
                  needs and expectations of the users and stakeholders in that domain¹. A software application domain
                  can be an organization, a department, a single workplace, or a specific problem area. A software
                  application domain usually has a domain-specific language, which is a set of terms and concepts that
                  are used and understood by the people in that domaim. Examples of software application domains are
                  banking, insurance, health care, education, gaming, etc.<br><br>

                  <strong>i. System software:</strong> <br><br>

                  System software is a type of software that is designed to provide a platform for other software. It
                  runs in the background, managing the computer's hardware and basic functions, so that users can run
                  application software to perform specific tasks. System software includes the operating system, which
                  is the best-known example of system software. The operating system controls all the other programs in
                  a computer, and provides an interface between the hardware and the user. Other examples of system
                  software are BIOS (basic input/output system), firmware, device drivers, language processors, system
                  utilities, etc. System software is usually written in a low-level computer language, such as assembly
                  or C, and is closely related to the hardware it runs on. System software is also hard to manipulate
                  and requires programming skills to use. System software is essential for the proper functioning of a
                  computer system, as it provides the foundation for application software to run on top of. <br><br>

                  Some of the advantages and disadvantages of system software are:<br><br>

                  Advantages:<br>

                  - It provides a platform for application software to run on top of.<br>
                  - It manages the computer's hardware and basic functions efficiently and reliably.<br>
                  - It protects the computer from unauthorized access and malicious attacks.<br>
                  - It enables communication and interaction between the hardware and the user.<br><br>

                  Disadvantages:<br>

                  - It is hard to manipulate and requires programming skills to use.<br>
                  - It is written in a low-level language that is difficult to understand and modify.<br>
                  - It is closely related to the hardware and may not be compatible with different devices or
                  platforms.<br>
                  - It may have bugs or errors that can affect the performance or security of the computer
                  system.<br><br>

                  <strong>ii. Application Software:</strong><br><br>

                  Application software is any program or interface that helps the end user perform certain functions. It
                  is designed for a specific purpose and runs on top of the system software, which provides the platform
                  for the application software to operate¹. Application software can be categorized into different
                  types, such as word processors, spreadsheets, databases, games, browsers, media players, etc.
                  Application software can be written in various programming languages, such as Java, Python, C++, etc.
                  Application software can be proprietary, open-source, or freeware. Application software can be
                  installed on a device or accessed through the internet. Application software can be customized or
                  modified by the user or the developer.<br><br>

                  Some of the advantages and disadvantages of application software are:<br><br>

                  Advantages:<br>

                  - It meets the specific needs of the user or the business.<br>
                  - It can be customized or modified by the user or the developer.<br>
                  - It can be accessed through the internet or installed on a device.<br>
                  - It can perform various tasks such as word processing, data analysis, gaming, etc.<br>
                  - It can be updated regularly by the developer for security and functionality.<br><br>

                  Disadvantages:<br>

                  - It can be expensive to develop or purchase.<br>
                  - It can be vulnerable to viruses or malicious attacks.<br>
                  - It can be incompatible with other software or platforms.<br>
                  - It can have bugs or errors that can affect the performance or quality of the output.<br><br>

                  <strong>iii. Embedded Software:</strong> <br><br>

                  Embedded software is a type of software that is used to operate electronic devices that are not
                  traditional computers. These types of devices include cars, biomedical devices, televisions, and
                  industrial robots. Embedded software is written specifically for the particular hardware that it runs
                  on and has time and memory constraintspp. Embedded software may or may not use an operating system,
                  depending on the complexity and functionality of the device. Embedded software is often written in
                  low-level languages such as assembly or C, and is closely related to the device drivers and firmware
                  that control the device's hardware. Embedded software is usually not visible or accessible to the
                  user, but performs essential tasks such as booting, controlling, monitoring, and communicating with
                  the device.<br><br>

                  Some of the advantages and disadvantages of embedded software are:<br><br>

                  Advantages:<br>

                  - It can operate very fast and efficiently on limited resources.<br>
                  - It can be lower cost and more reliable than general-purpose computers.<br>
                  - It can be customized and optimized for a specific device or function.<br>
                  - It can provide better security and performance for critical applications.<br><br>

                  Disadvantages:<br>

                  - It can be hard to develop, debug, and maintain.<br>
                  - It can be incompatible with other software or hardware platforms.<br>
                  - It can have limited functionality and scalability compared to general-purpose computers.<br>
                  - It can be vulnerable to hardware failures or environmental conditions.<br><br>

                  <strong>iv. Web Application:</strong> <br><br>

                  A web application is a computer program that utilizes web browsers and web technology to perform tasks
                  over the Internet. Web applications are accessed using a web browser, such as Google Chrome, Mozilla
                  Firefox or Safari. Web applications can provide various functions and services, such as webmail,
                  online shopping, video streaming, social media, games, etc. Web applications can be written in
                  different programming languages, such as HTML, CSS, JavaScript, PHP, Java, Python, etc. Web
                  applications can be hosted on a web server or a cloud platform. Web applications can be updated and
                  maintained easily by the developers without requiring the users to install anything on their
                  devices.<br><br>

                  Some of the advantages and disadvantages of web applications are:<br><br>

                  Advantages:<br>

                  - They can provide a better user experience with responsive design and cross-platform
                  compatibility.<br>
                  - They can be accessed from anywhere with an internet connection and a web browser.<br>
                  - They can be updated and maintained easily by the developers without requiring the users to install
                  anything on their devices.<br>
                  - They can be customized and modified by the users or the developers according to their needs.<br>
                  - They can be cheaper and faster to develop than native or hybrid applications.<br><br>

                  Disadvantages:<br>

                  - They rely on internet connectivity and may not work offline or with poor network conditions.<br>
                  - They may have security issues or vulnerabilities due to malicious attacks or data breaches.<br>
                  - They may have compatibility issues with some browsers or devices that do not support certain web
                  technologies.<br>
                  - They may have performance issues or limitations due to the web server or browser
                  capabilities.<br><br>

                  <strong>v. Artificial Intelligence Software </strong><br><br>

                  Artificial intelligence software is software that is capable of intelligent behavior, such as
                  reasoning, learning, problem-solving, perception, and knowledge representation. Artificial
                  intelligence software can perform tasks that typically require human intelligence, such as speech
                  recognition, natural language processing, computer vision, machine learning, data analysis, etc.
                  Artificial intelligence software can be written in various programming languages, such as Python,
                  Java, C++, etc. Artificial intelligence software can be used for various applications and domains,
                  such as healthcare, education, finance, gaming, robotics, etc. Artificial intelligence software can be
                  classified into different types or levels, such as narrow AI (which can perform a specific task),
                  general AI (which can perform any task that a human can), and super AI (which can perform any task
                  better than a human).<br><br>

                  Some of the advantages and disadvantages of artificial intelligence software are:<br><br>

                  Advantages:<br>

                  - It can reduce human error and increase accuracy and precision in performing complex tasks.<br>
                  - It can provide a better user interface and experience with natural language processing and computer
                  vision.<br>
                  - It can introduce new techniques and solutions to solve problems that humans may not be able to.<br>
                  - It can handle large amounts of data and information better than humans and convert them into
                  knowledge.<br>
                  - It can improve work efficiency and productivity by working 24/7 and automating repetitive
                  tasks.<br><br>

                  Disadvantages:<br>

                  - It can be expensive and difficult to develop, maintain, and update.<br>
                  - It can replace human jobs and cause unemployment or ethical issues.<br>
                  - It can be incompatible with other software or hardware platforms or have compatibility issues with
                  some browsers or devices.<br>
                  - It can have performance issues or limitations due to the web server or browser capabilities or have
                  security issues or vulnerabilities due to malicious attacks or data breaches.<br>
                  - It can lack emotion, creativity, or common sense and may not be able to handle unexpected situations
                  or moral dilemmas.<br>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                1.3 Software Engineering – A layered Approach
              </p>
              <div class="u-point-expand">
                <p>Here's a brief overview:
                </p>
                <p>
                  Software engineering is a layered technology that deals with process, methods, and their
                  implementation tools and finally the quality of the product. The layered approach of software
                  engineering is a systematic, disciplined, quantifiable approach to the development, operation, and
                  maintenance of software. The most common systematic approach taken is described as “layered”. The
                  layered approach offers some important advantages and benefits such as better decision-making, early
                  error detection.<br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/layered-technology-in-software-engineering/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                1.4 Generic Process Model
              </p>
              <div class="u-point-expand">
                <p>
                  A generic process model is an abstraction of the software development process. It describes the common
                  activities and tasks that are involved in most software projects, regardless of their size,
                  complexity, or domain. A generic process model consists of five framework activities: communication,
                  planning, modeling, construction, and deployment. These activities can be performed in different ways,
                  depending on the type of process flow (linear, iterative, or evolutionary) and the specific software
                  engineering actions and tasks that are defined for each activity. A generic process model provides a
                  base for developing more specific and tailored software process models that suit the needs and
                  characteristics of a particular project.<br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.educative.io/answers/what-is-the-generic-process-model-in-software-development">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                1.5 Generic Framework Activity, Umbrella Activity
              </p>
              <div class="u-point-expand">
                <p>
                  In software engineering, a "Generic Framework Activity" is a collection of interlinked boilerplate C++
                  classes that set the stage for scalable hierarchical activity processing using GameplayTags. The
                  framework primarily wants to scaffold other, more opinionated systems that also agree with this
                  world-crowd-agent style hierarchical activity execution approach. <br><br>

                  An "Umbrella activity" is a series of steps or procedures followed by a software development team to
                  maintain the progress, quality, changes, and risks of complete development tasks. These steps of
                  umbrella activities will evolve through the phases of the generic view of software development.<br>

                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/software-engineering-software-process-framework/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                1.6 Software Development Models
                i. Waterfall Model
                ii. Incremental Process Model
                iii. Prototype Model
                iv. Spiral Model
              </p>
              <div class="u-point-expand">
                <p>
                  The Software Development Life Cycle (SDLC) is a model that lays out the steps involved in software
                  development at each level. It includes a step-by-step guide to creating, deploying, and maintaining
                  software. <br><br>

                  Software Development life cycle (SDLC) is a spiritual model used in project management that defines
                  the stages include in an information system development project, from an initial feasibility study to
                  the maintenance of the completed application.<br><br>

                  Software Development Models are the models that define the process and the flow in which the project
                  needs be carried out, defines how the software should be developed based on the business and users’
                  requirements. These models help both developers and testers to develop the project properly. <br><br>

                  There are different types of software development models such as Iterative Model, Big bang model,
                  Prototype Model, Waterfall Model, Agile Model, Spiral Model, V-Model, RAD Model etc. <br>
                </p>
                <p>

                  <strong>i. Waterfall Model:</strong> <br><br>

                  The Waterfall Model is a breakdown of project activities into linear sequential phases, meaning they
                  are passed down onto each other, where each phase depends on the deliverables of the previous one and
                  corresponds to a specialization of tasks. <br><br>

                  The Waterfall model is the earliest SDLC approach that was used for software development. The
                  waterfall Model illustrates the software development process in a linear sequential flow. This means
                  that any phase in the development process begins only if the previous phase is complete.<br><br>

                  <strong>ii. Incremental Process Model:</strong><br><br>

                  The Incremental process model is also known as ‘Successive version model’. In the Incremental process
                  model, a series of releases, called increments, are built and delivered to the customer. First, a
                  simple working system (core product), that addresses basic requirements, is delivered. Then,
                  subsequent releases of the module add function to the previous release.<br><br>

                  In this model, each module goes through the requirements, design, implementation and testing
                  phases.<br><br>

                  <strong>iii. Prototype Model:</strong><br><br>

                  The Prototyping Model is one of the most popularly used Software Development Life Cycle Models (SDLC
                  models). This model is used when the customers do not know the exact project requirements beforehand.
                  In this model, a prototype of the end product is first developed, tested and refined as per customer
                  feedback repeatedly till a final product is developed.<br><br>

                  The prototyping model is a method of system development in which a prototype is created, tested, and
                  then reconstructed as necessary until an appropriate result is attained by which to develop the
                  complete system or product.<br><br>

                  <strong>iv. Spiral Model:</strong><br><br>

                  The Spiral model is a risk-driven software development process model. Based on the unique risk
                  patterns of a given project, the spiral model guides a team to adopt elements of one or more process
                  models, such as incremental, waterfall, or evolutionary prototyping.<br><br>

                  The Spiral Model is a risk-driven model, meaning that the focus is on managing risk through multiple
                  iterations of the software development process.<br>

                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.tutorialride.com/software-testing/software-development-process-models.htm/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                1.7 Agile Development Model
                i. Agility Principles
                ii. Agile Model vs Iterative Waterfall
                Model
              </p>
              <div class="u-point-expand">
                <p>
                  Agile Development Model is a software development model that was mainly intended for helping
                  developers build a project which can adapt to transforming requests quickly. The Agile software
                  development model depends on iterative software development. A completely independent operating
                  component is made after completing iteration. Iteration must not take more than two weeks in order to
                  complete the code. Agile methodologies invite the developers to build involved with testing rather
                  than an individual quality assurance group.<br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.javatpoint.com/software-engineering-agile-model">Link</a>
                </p>
                <p>
                  <strong>i. Agility Principles:</strong> <br><br>

                  Agility Principles are a set of principles that define the Agile software development approach. The
                  Agile Alliance defines twelve lightness principles for those that need to attain agility. Some of
                  these principles include:<br><br>

                  - Our highest priority is to satisfy the client through early and continuous delivery of valuable
                  computer software.<br>
                  - Welcome dynamical necessities, even late in development.<br>
                  - Agile processes harness modification for the customer’s competitive advantage.<br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/agile-software-process-and-its-principles/">Link</a>
                </p>
                <p>
                  <strong>ii. Agile Model vs Iterative Waterfall Model:</strong> <br><br>

                  The Waterfall model is a linear approach to software development that follows a sequential process of
                  requirements gathering, design, development, testing, and deployment. It is essentially making a good
                  plan and sticking to it. <br><br>

                  On the other hand, Agile project management takes an iterative approach to development by creating
                  several incremental steps with regular feedback intervals. This promotes adaptability since a team can
                  adjust throughout the product development process, rather than being confined to a linear path. Agile
                  is more a set of principles than one methodology.<br><br>

                  In summary, Waterfall is more sequential and pre-defined, while Agile utilises a more flexible,
                  iterative approach.<br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/difference-between-agile-model-and-iterative-model/amp/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                1.8 1.8 Types of widely used Agile Models
                i. Extreme Programming(XP)
                ii. Scrum
              </p>
              <div class="u-point-expand">
                <p>
                  There are several types of Agile models that are widely used in software engineering. Some of them
                  are: <br><br>

                  1. Scrum<br>
                  2. Crystal<br>
                  3. Dynamic Software Development Method (DSDM)<br>
                  4. Feature Driven Development (FDD)<br>
                  5. Lean Software Development<br>
                  6. Extreme Programming (XP)<br><br>

                  The Agile model is used when frequent changes need to be implemented.<br><br>

                  <strong>i. Extreme Programming (XP):</strong> <br><br>

                  Extreme Programming (XP) is a software development methodology intended to improve software quality
                  and responsiveness to changing customer requirements. It is one of the Agile software development
                  methodologies that provides values and principles to guide the team behavior. The team is expected to
                  self-organize. Extreme Programming provides specific core practices where each practice is simple and
                  self-complete.<br><br>

                  Extreme Programming has several advantages and disadvantages. Some of them are:<br><br>

                  Advantages:<br><br>

                  • Close contact with the customer<br>
                  • No unnecessary programming work<br>
                  • Stable software through continuous testing<br>
                  • Error avoidance through pair programming<br><br>

                  Disadvantages:<br><br>

                  • Additional work<br>
                  • Customer must participate in the process<br>
                  • Relatively large time investment<br>
                  • Relatively high costs<br><br>

                  <strong>ii. Scrum:</strong><br><br>

                  Scrum is an Agile framework that is used to develop and deliver high-quality software products. It is
                  a lightweight process framework that is used to manage complex software and product development. Scrum
                  is based on the principles of transparency, inspection, and adaptation. It is a team-based approach to
                  project management that emphasizes collaboration, flexibility, and customer satisfaction .<br><br>

                  Scrum has several advantages and disadvantages. Some of them are:<br><br>

                  Advantages:<br><br>
                  - Adaptability and flexibility<br>
                  - Creativity and innovation<br>
                  - Time to market<br>
                  - Lower costs<br>
                  - Increased transparency often leads to better communication and collaboration<br><br>

                  Disadvantages:<br><br>
                  - Requires extensive training<br>
                  - Can be difficult to scale<br>
                  - It can be difficult for the Scrum master to plan, structure and organize a project that lacks a
                  clear definition.<br>

                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.sealights.io/software-development-metrics/the-agile-process-scrum-kanban-and-xp/">Link</a>
                </p>
              </div>
            </div>
          </div>
          <div class="unit border py-3 mx-3 filterDiv unit-2" id="unit-2">
            <h4 class="fw-bold mb-3">Unit –2: Software Requirement Analysis and Design
            </h4>
            <div class="u-point">
                <p class="point">2.1 Requirement Gathering and Analysis</p>
                <div class="u-point-expand">
                  <p>
                    Requirement gathering and analysis is a crucial part of software development that involves collecting and analyzing information about what a software system should do and how it should behave. The process typically involves several steps such as gathering requirements, analyzing them, improving their quality, modeling them, documenting them, and reviewing them. <br><br>

The goal of requirement gathering and analysis is to ensure that the software system meets the needs of its users and stakeholders while also being feasible, testable, and maintainable. The process is usually carried out by business analysts who work closely with customers to identify their needs and translate them into functional requirements. <br><br>

There are several techniques that can be used for requirement gathering such as one-to-one interviews, group interviews, brainstorming, focused groups, document analysis, requirement workshops (JAD), visual techniques such as prototyping and wireframing, and questionnaires or surveys.<br><br> 

One-to-one interviews involve structured conversations with one person at a time where predetermined questions are asked and their answers are recorded. Group interviews work best with interviewees of the same job position or level as they are familiar with each other's work. Brainstorming involves generating ideas in a group setting. Focused groups involve gathering a small group of people who have similar roles or interests. Document analysis involves reviewing existing documents such as reports, manuals, and procedures. Requirement workshops (JAD) involve bringing together stakeholders to define requirements in a structured workshop environment. Visual techniques such as prototyping and wireframing involve creating visual representations of the software system. Questionnaires or surveys involve sending out questionnaires to stakeholders to gather their requirements.<br>
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/software-engineering-requirement-analysis">Link</a>
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">2.2 Software Requirement Specification (SRS) 
                    i. Characteristic 
                    ii. Customer requirement 
                    iii. Functional Requirement</p>
                <div class="u-point-expand">
                  <p>
                    A Software Requirements Specification (SRS) is a description of a software system to be developed. It is modeled after business requirements specification (CONOPS). An SRS is a comprehensive document that describes your future project in detail: from its functionality and features to technologies and exact ways they should be implemented. It also describes the functionality the product needs to fulfill the needs of all stakeholders (business, users). You can think of an SRS as a blueprint or roadmap for the software you're going to build. The elements that comprise an SRS can be simply summarized into four Ds: <br><br>

- Description: A detailed description of what the software will do.<br>
- Design: A detailed description of how the software will do it.<br>
- Development: A detailed description of how the software will be built.<br>
- Deployment: A detailed description of how the software will be deployed.
<br><br>
  
                    <strong>i. Characteristic:</strong> <br><br>
  
                    The characteristics of an SRS are as follows:<br><br>

- Correct: User review is used to ensure the correctness of requirements stated in the SRS.<br>
- Complete: Completeness of SRS indicates every sense of completion including the numbering of all the pages.<br>
- Unambiguous: The SRS document should be concise at the same time unambiguous, consistent, and complete.<br>
- Verifiable: The SRS should be verifiable by inspection, analysis, demonstration, or test.<br>
- Consistent: The SRS should be consistent with other documentation and plans.<br>
- Ranked for importance and/or stability: Requirements should be ranked for importance and/or stability.<br>
- Modifiable: The SRS should be modifiable as changes occur in the requirements.
<br><br>
  
                    <strong>ii. Customer requirement:</strong><br><br>
  
                    Software requirements specification (SRS) is a document that describes what the software will do, how it will perform, and what functionality it needs to fulfill the needs of customers, users, and stakeholders. It forms the basis for agreement between customers and development organization on what the software product is expected to do. The requirement is nothing but a condition needed by the user to solve a problem or achieve an objective.<br><br>

Customer requirements are characteristics that determine whether or not the customer is happy. Examples of customer requirements include quality, price, functionality, performance, convenience, safety, compatibility, and available options. Here are a few examples of customer needs:<br><br>
- Fast, reliable customer service<br>
- Convenient ways to get help, such as through messaging channels<br>
- Options for getting in touch with customer support<br>
- A knowledge base that enables customers to solve issues on their own, 24/7<br>
- Friendly, empathetic agents<br>
- Sustainable products and socially conscious brands<br>
- Seamless returns<br>
- Transparent pricing<br><br>
  
                    <strong>iii. Functional Requirement :</strong> <br><br>
  
                    Functional requirements in an SRS document (software requirements specification) indicate what a software system must do and how it must function; they are product features that focus on user needs. The functional requirements should address what software is supposed to do and its performance. <br><br>

Functional requirements need to be clear, simple, and unambiguous. Examples of functional requirements include user authentication, data processing rules, calculations, data storage, security features and access control mechanisms. Here are some examples of well-written functional requirements:<br><br>
- The system must send a confirmation email whenever an order is placed.<br>
- The system must allow blog visitors to sign up for the newsletter by leaving their email.
<br><br>
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/software-requirement-specifications">Link</a>
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  2.3 Software Requirement 
                  Specification(SRS) 
                </p>
                <div class="u-point-expand">
                  <p>Above we are see
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  2.4 Software Design
                  i. Characteristics of good software 
                  design
                  ii. Analysis v/s design
                </p>
                <div class="u-point-expand">
                  <p>
                    Software design is the process of envisioning and defining software solutions to one or more sets of problems. It is a mechanism to transform user requirements into some suitable form, which helps the programmer in software coding and implementation. For assessing user requirements, an SRS (Software Requirement Specification) document is created whereas for coding and implementation, there is a need for more specific and detailed requirements.<br><br>

                    <strong>i. Characteristics of good software design</strong><br><br>

Good software design has several key attributes such as functionality, usability, reliability, maintainability, efficiency, portability, and scalability. Six characteristics of good software design are simplicity, coupling, cohesion, information hiding, performance, and security. Correctness and understandability are also important characteristics of good software design.<br><br>

Functionality : Software functionality refers to the sum or any aspect of what a product, such as a software application or computing device, can do for a user. A functional requirement (FR) is a description of the service that the software must offer. It describes a software system or its component.<br><br>

Usability: Software usability refers to the degree to which a software can be used by specified consumers to achieve quantified objectives with effectiveness, efficiency, and satisfaction in a quantified context of use. It is a measure of how well a specific user in a specific context can use a product/design to achieve a defined goal effectively, efficiently and satisfactorily.<br><br>

Reliability: Software reliability is an essential component of software quality, along with other characteristics like functionality, usability, performance, etc. It means that the software performs consistently and accurately, and is trustworthy. Software reliability metrics and models are used to measure and improve the reliability of software systems.<br><br>

Maintainability: Software maintainability refers to the ease with which you can repair, improve and understand software code. It is a phase in the software development cycle that starts after the customer has received the product. Developers take care of maintainability by continuously adapting software to meet new customer requirements and address problems faced by customers.<br><br>

Efficiency: Software efficiency refers to the ability of the software to use system resources in the most effective and efficient manner. It means that waste is avoided and that the software should make effective use of storage space and executive command as per desired timing requirements.<br><br>

Portability: Software portability refers to the possibility of using the same software in different environments. It applies to software that is available for two or more different platforms or can be recompiled for them. Common types of portability include application, source code, and data portability.<br>

Scalability: Software scalability refers to the ability of a software application to grow and handle increasing amounts of data and user requests. A scalable software doesn’t need to be redesigned to maintain effective performance after an increased workload. It is a measure of how easy it is to grow or shrink a piece of software. In many cases, it refers to the software’s ability to handle increased workloads while adding users and removing them with minimal cost impact. Often software scalability also refers to the software’s ability to perform and support growing amounts of data.<br><br>

<strong>ii. Analysis v/s design</strong><br><br>

Here are some differences between Agile and Design:

                </p>
                <div class="table-container">
                    <table class="table table-bordered">
                      <thead>
                        <tr>
                          <th class="table-head">Sr No.</th>
                          <th class="table-head">Agile</th>
                          <th class="table-head">Design</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">1</td>
                          <td>Agile is a project management method used to build better software.</td>
                          <td>Design can be used to solve any big complex problem that has no clear solution.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">2</td>
                          <td>Agile requires user engagement.</td>
                          <td>Design provides users with a way to make better choices about the journeys they should follow, not just how best to get there.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">3</td>
                          <td>Agile is a method to solve predefined problems.</td>
                          <td> Design focuses on finding the right problems to solve.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">4</td>
                          <td>Agile favors building working software.</td>
                          <td>Design favors building UI mockups, sketches, and similar visual artifacts.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">5</td>
                          <td>Agile is more focused on execution.</td>
                          <td>Design is more flexible and iterative.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">6</td>
                          <td>Agile emphasizes speed and efficiency.</td>
                          <td>Design emphasizes creativity and innovation.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">7</td>
                          <td>Agile is more about the process. </td>
                          <td>Design is more about the outcome.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">8</td>
                          <td>Agile is more about building software.</td>
                          <td>Design is more about building experiences.</td>
                        </tr>
                        <tr>
                          <td style="text-align: center; vertical-align: middle; width: 8.7755%;">9</td>
                          <td>Agile is more about delivering value to customers.</td>
                          <td>Design is more about understanding customers.</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/software-engineering-software-design">Link</a>
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  2.5 Cohesion & Coupling
                  i. Classification of cohesion 
                  ii. Classification of coupling 
                </p>
                <div class="u-point-expand">
                  <p>
                    In software engineering, **coupling** refers to the degree of interdependence between software modules. High coupling means that modules are closely connected and changes in one module may affect other modules. On the other hand, **cohesion** is the indication of the relationship within the module. It is the concept of intra-module. Cohesion has many types but usually, high cohesion is good for software.<br><br>

Both coupling and cohesion are important factors in determining the maintainability, scalability, and reliability of a software system. High coupling and low cohesion can make a system difficult to change and test, while low coupling and high cohesion make a system easier to maintain and improve.
<br><br>
<strong>i. Classification of cohesion</strong> <br><br>

In software engineering, there are different types of cohesion. Some of them are:<br><br>

- Coincidental cohesion: If a module performs certain set of tasks that relate to each other very loosely or doesn’t relate at all then the module is said to possess coincidental cohesion. This cohesion is the weakest of all.<br>
- Logical cohesion: If a module performs a set of logically related tasks then it is said to possess logical cohesion.<br>
- Temporal cohesion: If a module performs a set of tasks that are related by time then it is said to possess temporal cohesion.<br>
- Procedural cohesion: If a module performs a set of tasks that are related by some sequence then it is said to possess procedural cohesion.<br>
- Communicational cohesion: If a module performs a set of tasks that operate on the same input data or output data then it is said to possess communicational cohesion.<br>
- Functional cohesion: If a module performs only one task then it is said to possess functional cohesion.<br><br>

These types of cohesion help in determining how well-designed and maintainable the software system is.<br><br>

<strong>ii. Classification of coupling</strong> <br><br>

In software engineering, coupling refers to the degree of interdependence between software modules. High coupling means that modules are closely connected and changes in one module may affect other modules. Low coupling means that modules are independent and changes in one module have little impact on other modules.<br><br>

There are different types of coupling in software engineering. Some of them are:<br><br>

- Content coupling: Two modules share data through shared memory or global variables.<br>
- Common coupling: Two modules share data through a global variable.<br>
- Control coupling: One module controls the flow of another module by passing it information on what to do.<br>
- Stamp coupling: Two modules share a composite data structure and use only a part of it.<br>
- Data coupling: Two modules communicate by passing data.<br>
- Message coupling: Two modules communicate by passing messages.<br><br>

These types of coupling help in determining how well-designed and maintainable the software system is.
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/">Link</a>
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  Function Oriented Software Design <br>
                  2.6 Data Flow Diagram(DFD)
                  i. Context Diagram
                  ii. Level 1 DFD
                </p>
                <div class="u-point-expand">
                  <p>
                    A Data Flow Diagram (DFD) is a graphical representation of the flow of data through an information system. It shows how data enters and leaves the system, what changes the information, and where data is stored. DFDs are used to understand the flow of data within a system, identify areas where data might be lost or corrupted, and identify areas where data might be improved. <br><br>

DFDs can be drawn to represent the system of different levels of abstraction. Higher-level DFDs are partitioned into low levels-hacking more information and functional elements. Levels in DFD are numbered 0, 1, 2 or beyond. <br><br>

DFDs are well suited for analysis or modeling of various types of systems in different fields. They can provide a focused approached to technical development, in which more research is done up front to get to coding.
<br>
                  </p>
                  <p>
  
                    <strong>i. Context Diagram</strong> <br><br>
  
                    A context diagram is a high-level view of a system. It’s a basic sketch meant to define an entity based on its scope, boundaries, and relation to external components like stakeholders. Otherwise known as a Level 0 data flow diagram, a context diagram provides a general overview of a process, focusing on its interaction with outside elements.<br><br> 

In software engineering DFD (data flow diagram), it is decomposed and described as a DFD with multiple bubbles. It represents the entire system as a single bubble with input and output data indicated by incoming/outgoing arrows.<br><br>

  
                    <strong>ii. Level 1 DFD</strong><br><br>
  
                    A level 1 DFD (Data Flow Diagram) breaks down the main process into subprocesses that can then be seen on a more deep level. A level 1 DFD notates each of the main sub-processes that together form the complete system. It contains data stores that are used by the main process.<br><br>

A data flow diagram can dive into progressively more detail by using levels and layers, zeroing in on a particular piece. DFD levels are numbered 0, 1 or 2, and occasionally go to even Level 3 or beyond. The necessary level of detail depends on the scope of what you are trying to accomplish. DFD Level 0 is also called a Context Diagram.<br>
  
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:<br><br>
                    DFD:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/software-engineering-data-flow-diagrams">Link</a><br><br>
                      Context Diagram:
                      <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://miro.com/blog/context-diagram/#:~:text=context%20diagram%20today-,What%20are%20context%20diagrams%3F,the%20scope%20of%20a%20system.">Link</a>
                    </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  Object Modeling with UML <br>
2.7 Use case Diagram
                </p>
                <div class="u-point-expand">
                  <p>
                    A use case diagram in UML (Unified Modeling Language) can summarize the details of your system's users (also known as actors) and their interactions with the system. To build one, you'll use a set of specialized symbols and connectors. An effective use case diagram can help your team discuss and represent:<br><br>

- The goals of system-user interactions<br>
- Defining and organizing functional requirements in a system<br>
- Specifying the context and requirements of a system<br>
- Modeling the basic flow of events in a use case.
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/uml-use-case-diagram">Link</a>
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  2.8 Class Diagram
                </p>
                <div class="u-point-expand">
                  <p>
                    A class diagram in UML (Unified Modeling Language) is a type of static structure diagram that describes the structure of a system by showing the system's classes, their attributes, operations (or methods), and the relationships among objects. The class diagram is the main building block of object-oriented modeling.<br><br>

Class diagrams are one of the most useful types of diagrams in UML as they clearly map out the structure of a particular system by modeling its classes, attributes, operations, and relationships between objects⁴. The UML Class diagram is a graphical notation used to construct and visualize object-oriented systems. <br><br>

The class diagram is made up of three sections: Upper Section, Middle Section and Lower Section. The upper section encompasses the name of the class. A class is a representation of similar objects that... Capitalize the initial letter of the class name. Place the class name in the center of the upper section. A class name must be unique within a namespace.
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/uml-use-case-diagram">Link</a>
                  </p>
                </div>
              </div>
              <div class="u-point">
                <p class="point">
                  2.9 Sequence Diagram
                </p>
                <div class="u-point-expand">
                  <p>
                    A sequence diagram in UML (Unified Modeling Language) is a type of interaction diagram that details how operations are carried out -- what messages are sent and when. Sequence diagrams are organized according to time. The time progresses as you go down the page. The objects involved in the operation are listed from left to right according to when they take part in the message sequence.<br><br>

Sequence diagrams are useful for dynamic modeling and mapping customer journeys. They capture the interaction between objects in the context of a collaboration. Sequence Diagrams are time focus and they show the order of the interaction visually by using the vertical axis of the diagram to represent time what messages are sent and when.

                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.javatpoint.com/uml-sequence-diagram#:~:text=The%20sequence%20diagram%20represents%20the,part%20at%20the%20run%20time.">Link</a>
                  </p>
                </div>
              </div><div class="u-point">
                <p class="point">
                  2.10 Activity Diagram
                </p>
                <div class="u-point-expand">
                  <p>
                    An activity diagram in UML (Unified Modeling Language) is a type of behavior diagram that shows how processes operate with one another and in what order. It depicts the objects and classes involved in the scenario and the sequence of activities needed to carry out the functionality of the scenario. <br><br>

Activity diagrams are similar to flowcharts because they show the flow between the actions in an activity; however, activity diagrams can also show parallel or concurrent flows and alternate flows. The diagram consists of shapes connected with arrows, with ellipses representing actions, diamonds representing decisions, and bars representing the start or end of concurrent activities.
                  </p>
                  <p class="fw-bold fs-6">
                    READ MORE:
                    <a class="text-primary text-decoration-none read-more" target=”_blank”
                      href="https://www.tutorialspoint.com/uml/uml_activity_diagram.htm">Link</a>
                  </p>
                </div>
              </div>
          </div>
          <div class="unit border py-3 mx-3 filterDiv unit-3" id="unit-3">
            <h4 class="fw-bold mb-3">Unit –3: Software Project Estimation & Scheduling
            </h4>
            <div class="u-point">
              <p class="point">3.1 Responsibility of software project Manager</p>
              <div class="u-point-expand">
                <p>
                  Software project managers are responsible for planning, scheduling, budgeting, executing, and delivering software and web projects¹. They ensure the successful completion of all software projects and also oversee the people performing work on the projects. Some of their responsibilities include discussing potential projects and their parameters with clients, executives, and software developers; planning out the blueprints for software projects; assembling and leading the project team; participating in and supervising each stage of the project. They also define the scope of the project, allocate resources, set deadlines, lay out communication strategies, and indicate tests and maintenance. They manage human resources by acting as a project leader and communicating with stakeholders. They monitor progress and performance, conduct risk analysis at every phase, and manage time and budget constraints. 

                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/software-engineering-responsibilities-of-software-project-manager/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">3.2  Metrics for Size Estimation 
                i. Line of Code 
                ii. Function Points </p>
              <div class="u-point-expand">
                <p>
                  Metrics for size estimation are used to estimate the size of a software project. Four metrics are popularly being used to estimate size: counting lines, lines of code (LOC), function point (FP), and feature poin
                   
                  <strong>i. Line of Code</strong> 
                  
                  Line of Code (LOC) is a software metric used to measure the size of a software program by counting the number of lines in the text of the program's source code. It is a simple and widely used metric for measuring software size. 
                  
                  However, it has some limitations as it does not take into account the quality of code or how complex it is. For example, two programs with the same number of lines of code may have different levels of complexity and quality. 
                   
<br><br>

                  <strong>ii. Function Points</strong> <br><br>

                  Function Point (FP) is a software metric used to measure the size of a software program by quantifying its functionality provided to the user based on user requirements. It is an industry-standard method for measuring software size and complexity. 

                  Function points consider factors such as inputs, outputs, inquiries, and files to arrive at the project size estimate. 
                   
<br><br>
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/software-engineering-project-size-estimation-techniques/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                3.3 Project Estimation Techniques using COCOMO model 
              </p>
              <div class="u-point-expand">
                <p>
                  COCOMO stands for COnstructive COst MOdel. The COCOMO model is a software cost estimation model that uses a set of equations to estimate the effort required to develop a software project. The model is based on three different levels of detail: Basic COCOMO, Intermediate COCOMO, and Detailed COCOMO.

                  Here are some of the project estimation techniques using the COCOMO model:
                  
                  1. Basic COCOMO: This technique uses a simple formula to estimate the effort required to develop a software project based on its size in lines of code.
                  
                  2. Intermediate COCOMO: This technique takes into account additional factors such as the complexity of the software, the experience of the development team, and the use of modern programming practices.
                  
                  3. Detailed COCOMO: This technique provides a more detailed estimate of the effort required to develop a software project by taking into account additional factors such as the size and complexity of the software, the experience and skill level of the development team, and the use of modern programming practices.
                  
                  1. Basic COCOMO:

                  Basic COCOMO is the simplest version of the COCOMO model. It uses a simple formula to estimate the effort required to develop a software project based on its size in lines of code (LOC). 
                  
                  The formula is as follows:
                  
                  **Effort = a x (LOC)^b**
                  
                  Where:
                  - **a** and **b** are constants that depend on the type of software being developed.
                  - **LOC** is the estimated size of the software project in lines of code.
                  
                  The basic COCOMO model assumes that the software being developed is relatively simple and that the development team has average experience and skill level.
                  
                  2. Intermediate COCOMO: 
                  
                  Intermediate COCOMO is a more detailed version of the COCOMO model that takes into account additional factors such as the complexity of the software, the experience of the development team, and the use of modern programming practices.
                  
                  The formula for Intermediate COCOMO is as follows:
                  
                  **Effort = a x (KLOC)^b x EAF**
                  
                  Where:
                  - **a** and **b** are constants that depend on the type of software being developed.
                  - **KLOC** is the estimated size of the software project in thousands of lines of code.
                  - **EAF** is the Effort Adjustment Factor that takes into account additional factors such as the complexity of the software, the experience and skill level of the development team, and the use of modern programming practices.

                  Intermediate COCOMO provides a more accurate estimate of the effort required to develop a software project than Basic COCOMO.

                  3. Detailed COCOMO: 
                  
                  Detailed COCOMO is the most detailed version of the COCOMO model that provides a more accurate estimate of the effort required to develop a software project by taking into account additional factors such as the size and complexity of the software, the experience and skill level of the development team, and the use of modern programming practices.
                  
                  The formula for Detailed COCOMO is as follows:
                  
                  **Effort = a x (KLOC)^b x EAF x (1.0 + Sum(i=1 to n) Pi)**
                  
                  Where:
                  - **a** and **b** are constants that depend on the type of software being developed.
                  - **KLOC** is the estimated size of the software project in thousands of lines of code.
                  - **EAF** is the Effort Adjustment Factor that takes into account additional factors such as the complexity of the software, the experience and skill level of the development team, and the use of modern programming practices.
                  - **Pi** are cost drivers that take into account additional factors such as hardware constraints, software reliability requirements, and database size.
                  
                  Detailed COCOMO provides the most accurate estimate of the effort required to develop a software project but requires more detailed information about the project than Basic or Intermediate COCOMO.                  
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href=" https://www.geeksforgeeks.org/software-engineering-cocomo-model/">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                2.4 Software Design
                i. Characteristics of good software 
                design
                ii. Analysis v/s design
              </p>
              <div class="u-point-expand">
                <p>
                  Software design is the process of envisioning and defining software solutions to one or more sets of problems. It is a mechanism to transform user requirements into some suitable form, which helps the programmer in software coding and implementation. For assessing user requirements, an SRS (Software Requirement Specification) document is created whereas for coding and implementation, there is a need for more specific and detailed requirements.<br><br>

                  <strong>i. Characteristics of good software design</strong><br><br>

Good software design has several key attributes such as functionality, usability, reliability, maintainability, efficiency, portability, and scalability. Six characteristics of good software design are simplicity, coupling, cohesion, information hiding, performance, and security. Correctness and understandability are also important characteristics of good software design.<br><br>

Functionality : Software functionality refers to the sum or any aspect of what a product, such as a software application or computing device, can do for a user. A functional requirement (FR) is a description of the service that the software must offer. It describes a software system or its component.<br><br>

Usability: Software usability refers to the degree to which a software can be used by specified consumers to achieve quantified objectives with effectiveness, efficiency, and satisfaction in a quantified context of use. It is a measure of how well a specific user in a specific context can use a product/design to achieve a defined goal effectively, efficiently and satisfactorily.<br><br>

Reliability: Software reliability is an essential component of software quality, along with other characteristics like functionality, usability, performance, etc. It means that the software performs consistently and accurately, and is trustworthy. Software reliability metrics and models are used to measure and improve the reliability of software systems.<br><br>

Maintainability: Software maintainability refers to the ease with which you can repair, improve and understand software code. It is a phase in the software development cycle that starts after the customer has received the product. Developers take care of maintainability by continuously adapting software to meet new customer requirements and address problems faced by customers.<br><br>

Efficiency: Software efficiency refers to the ability of the software to use system resources in the most effective and efficient manner. It means that waste is avoided and that the software should make effective use of storage space and executive command as per desired timing requirements.<br><br>

Portability: Software portability refers to the possibility of using the same software in different environments. It applies to software that is available for two or more different platforms or can be recompiled for them. Common types of portability include application, source code, and data portability.<br>

Scalability: Software scalability refers to the ability of a software application to grow and handle increasing amounts of data and user requests. A scalable software doesn’t need to be redesigned to maintain effective performance after an increased workload. It is a measure of how easy it is to grow or shrink a piece of software. In many cases, it refers to the software’s ability to handle increased workloads while adding users and removing them with minimal cost impact. Often software scalability also refers to the software’s ability to perform and support growing amounts of data.<br><br>

<strong>ii. Analysis v/s design</strong><br><br>

Here are some differences between Agile and Design:

              </p>
              <div class="table-container">
                  <table class="table table-bordered">
                    <thead>
                      <tr>
                        <th class="table-head">Sr No.</th>
                        <th class="table-head">Agile</th>
                        <th class="table-head">Design</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">1</td>
                        <td>Agile is a project management method used to build better software.</td>
                        <td>Design can be used to solve any big complex problem that has no clear solution.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">2</td>
                        <td>Agile requires user engagement.</td>
                        <td>Design provides users with a way to make better choices about the journeys they should follow, not just how best to get there.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">3</td>
                        <td>Agile is a method to solve predefined problems.</td>
                        <td> Design focuses on finding the right problems to solve.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">4</td>
                        <td>Agile favors building working software.</td>
                        <td>Design favors building UI mockups, sketches, and similar visual artifacts.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">5</td>
                        <td>Agile is more focused on execution.</td>
                        <td>Design is more flexible and iterative.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">6</td>
                        <td>Agile emphasizes speed and efficiency.</td>
                        <td>Design emphasizes creativity and innovation.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">7</td>
                        <td>Agile is more about the process. </td>
                        <td>Design is more about the outcome.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">8</td>
                        <td>Agile is more about building software.</td>
                        <td>Design is more about building experiences.</td>
                      </tr>
                      <tr>
                        <td style="text-align: center; vertical-align: middle; width: 8.7755%;">9</td>
                        <td>Agile is more about delivering value to customers.</td>
                        <td>Design is more about understanding customers.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.javatpoint.com/software-engineering-software-design">Link</a>
                </p>
              </div>
            </div>
            <div class="u-point">
              <p class="point">
                2.5 Cohesion & Coupling
                i. Classification of cohesion 
                ii. Classification of coupling 
              </p>
              <div class="u-point-expand">
                <p>
                  In software engineering, **coupling** refers to the degree of interdependence between software modules. High coupling means that modules are closely connected and changes in one module may affect other modules. On the other hand, **cohesion** is the indication of the relationship within the module. It is the concept of intra-module. Cohesion has many types but usually, high cohesion is good for software.<br><br>

Both coupling and cohesion are important factors in determining the maintainability, scalability, and reliability of a software system. High coupling and low cohesion can make a system difficult to change and test, while low coupling and high cohesion make a system easier to maintain and improve.
<br><br>
<strong>i. Classification of cohesion</strong> <br><br>

In software engineering, there are different types of cohesion. Some of them are:<br><br>

- Coincidental cohesion: If a module performs certain set of tasks that relate to each other very loosely or doesn’t relate at all then the module is said to possess coincidental cohesion. This cohesion is the weakest of all.<br>
- Logical cohesion: If a module performs a set of logically related tasks then it is said to possess logical cohesion.<br>
- Temporal cohesion: If a module performs a set of tasks that are related by time then it is said to possess temporal cohesion.<br>
- Procedural cohesion: If a module performs a set of tasks that are related by some sequence then it is said to possess procedural cohesion.<br>
- Communicational cohesion: If a module performs a set of tasks that operate on the same input data or output data then it is said to possess communicational cohesion.<br>
- Functional cohesion: If a module performs only one task then it is said to possess functional cohesion.<br><br>

These types of cohesion help in determining how well-designed and maintainable the software system is.<br><br>

<strong>ii. Classification of coupling</strong> <br><br>

In software engineering, coupling refers to the degree of interdependence between software modules. High coupling means that modules are closely connected and changes in one module may affect other modules. Low coupling means that modules are independent and changes in one module have little impact on other modules.<br><br>

There are different types of coupling in software engineering. Some of them are:<br><br>

- Content coupling: Two modules share data through shared memory or global variables.<br>
- Common coupling: Two modules share data through a global variable.<br>
- Control coupling: One module controls the flow of another module by passing it information on what to do.<br>
- Stamp coupling: Two modules share a composite data structure and use only a part of it.<br>
- Data coupling: Two modules communicate by passing data.<br>
- Message coupling: Two modules communicate by passing messages.<br><br>

These types of coupling help in determining how well-designed and maintainable the software system is.
                </p>
                <p class="fw-bold fs-6">
                  READ MORE:
                  <a class="text-primary text-decoration-none read-more" target=”_blank”
                    href="https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/">Link</a>
                </p>
              </div>
            </div>
         
          </div>
          <div class="unit border py-3 mx-3 filterDiv unit-4" id="unit-4">
            <h4 class="fw-bold mb-3">Unit –4: Software Coding and testing
            </h4>
            <div include-html="coming.html"></div>
          </div>
          <div class="col filterDiv PDFs-ise py-3 mx-3">
            <div class="card shadow-sm">
              <div class="card-body pdf-section">
                <div class="btn-group" role="group" aria-label="Basic outlined example">
                  <label>ISE Syllabus</label>
                  <button type="button" class="btn btn-outline-primary">
                    <a class="text-decoration-none" target="_blank" href="https://drive.google.com/file/d/1lrckwJQLDMG0ieNMfozk1ZFf81HCO1jP/view?usp=drivesdk" download>Download</a></button>
                </div>
                <div class="btn-group" role="group" aria-label="Basic outlined example">
                  <label>ISE Projects Link</label>
                  <button type="button" class="btn btn-outline-primary">
                    <a class="text-decoration-none" target="_blank" href="https://www.tutorialsduniya.com/software-engineering-projects-pdf/">View</a></button>
                </div>
              </div>
            </div>
          </div>

          </div>
        </div>
      </div>

      <!-- </div> -->
    </div>
  </section>

  <div include-html="footer.html"></div>

</body>

<script src="../script.js"></script>

<script>
  includeHTML();
</script>

</html>
